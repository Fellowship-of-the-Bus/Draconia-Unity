using UnityEngine;
using UnityEditor;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;

////////////////
// Want:
//   * specify multiple languages in different files, each file must have same number of strings
//   * enum for key so that access is checked by compiler
//
// soln: two modes:
//   specify key set
//   given a keyset, show the list of strings that need to be filled out

// TODO:
// * display window as dirty when changes are pending
// * prompt save before new/load if dirty

[System.Serializable]
public class StringKeys {
  public string[] keys;
}

[System.Serializable]
public class StringValues {
  public string keysPath;
  public string[] values;
}

public class StringsEditor : EditorWindow {
  public enum Mode {
    Blank, Keys, Values
  }
  public Mode mode;
  public StringKeys keys;
  public StringValues values;
  private EditorFileManager keysFileManager;
  private EditorFileManager valuesFileManager;
  private Channel channel = new Channel("StringsEditor", true);

  [MenuItem("Window/Strings Editor")]
  static void Init() {
    EditorWindow.GetWindow(typeof(StringsEditor)).Show();
  }

  private void OnGUI() {
    switch(mode) {
      case Mode.Blank: drawBlank(); break;
      case Mode.Keys:  drawKeys(); break;
      case Mode.Values: drawValues(); break;
    }
  }

  private void drawBlank() {
    if (GUILayout.Button("New Keys")) {
      keys = new StringKeys();
      keysFileManager.Reset();
      mode = Mode.Keys;
    }
    if (GUILayout.Button("Load Keys")) {
      if (LoadKeys()) {
        mode = Mode.Keys;
      }
    }
    if (GUILayout.Button("New Values")) {
      if (LoadKeys()) {
        calcWidth();
        values = new StringValues();
        values.keysPath = keysFileManager.activeFilePath;
        values.values = new string[keys.keys.Length];
        valuesFileManager.Reset();
        mode = Mode.Values;
      }
    }
    if (GUILayout.Button("Load Values")) {
      if (LoadValues()) {
        calcWidth();
        mode = Mode.Values;
      }
    }
  }

  // needed to maintain scroll position between draw calls
  private Vector2 scrollPos;
  private void drawKeys() {
    scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
    SerializedObject serializedObject = new SerializedObject(this);
    SerializedProperty serializedProperty = serializedObject.FindProperty("keys.keys");
    EditorGUILayout.PropertyField(serializedProperty, true);
    serializedObject.ApplyModifiedProperties();

    if (GUILayout.Button("Save data")) {
      SaveKeys();
    }
    EditorGUILayout.EndScrollView();

    drawBlank();
  }

  private void drawValues() {
    Debug.Assert(keys.keys.Length == values.values.Length);

    scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
    SerializedObject serializedObject = new SerializedObject(this);
    SerializedProperty serializedProperty = serializedObject.FindProperty("values.values");
    for (int i = 0; i < keys.keys.Length; ++i) {
      EditorGUILayout.BeginHorizontal();
      GUILayout.Label(keys.keys[i], GUILayout.Width(maxWidth));
      SerializedProperty elem = serializedProperty.GetArrayElementAtIndex(i);
      EditorGUILayout.PropertyField(elem, GUIContent.none, true);
      EditorGUILayout.EndHorizontal();
    }
    serializedObject.ApplyModifiedProperties();

    if (GUILayout.Button("Save data")) { // TODO: should just ask for language/location - name should be decided by key name
      SaveValues();
    }
    EditorGUILayout.EndScrollView();

    drawBlank();
  }

  private void SaveKeys() {
    keysFileManager.Save(keys);
    string activeFilePath = keysFileManager.activeFilePath;
    if (!string.IsNullOrEmpty(activeFilePath)) {
      int begin = activeFilePath.LastIndexOf(Path.DirectorySeparatorChar) + 1;
      int end = activeFilePath.LastIndexOf('.');
      string baseName = activeFilePath.Substring(begin, end-begin);
      channel.Log("baseName is: " + baseName);

      // write enum type
      DirectoryInfo dir = System.IO.Directory.CreateDirectory(scriptPath);
      StreamWriter stream = new StreamWriter(Path.Combine(scriptPath, baseName + ".cs"));
      stream.WriteLine("// This file is automatically generated. Do no make any changes here, they will be overwritten.");
      stream.WriteLine("// All changes should be made through the StringsEditor window.");
      stream.WriteLine("namespace StringID {");
      stream.WriteLine("  public enum " + baseName + " {");
      for (int i = 0; i < keys.keys.Length; ++i) {
        stream.WriteLine("    " + keys.keys[i] + ",");
      }
      stream.WriteLine("  }");
      stream.WriteLine("}");
      stream.Flush();
      stream.Close();
    }
  }

  private void SaveValues() {
    valuesFileManager.Save(values);
  }

  private bool LoadKeys() {
    return keysFileManager.Load(ref keys);
  }

  private bool LoadValues() {
    // TODO: cache previous values for restore on fail to load
    // TODO: needs to do a santity check that data has not gotten out of sync with keys
    if (valuesFileManager.Load(ref values)) {
      keysFileManager.activeFilePath = values.keysPath;
      return keysFileManager.Load(ref keys);
    }
    return false;
  }

  private static string scriptPath;

  void OnEnable() {
    scriptPath = Path.Combine(Application.dataPath, "Script/generated/strings");
    keysFileManager = new EditorFileManager(
      serializer: new BinarySerializer(),
      saveTitle: "Save keys file",
      loadTitle: "Select keys file",
      path: Path.Combine(Application.dataPath, "StringsData/keys"),
      extension: "stringkeys"
    );
    valuesFileManager = new EditorFileManager(
      serializer: new BinarySerializer(),
      saveTitle: "Save values file",
      loadTitle: "Select values file",
      path: Path.Combine(Application.dataPath, "StringsData"),
      extension: "stringvalues"
    );
  }

  private float maxWidth = 0f;
  private void calcWidth() {
    for (int i = 0; i < keys.keys.Length; ++i) {
      var textDimensions = GUI.skin.label.CalcSize(new GUIContent(keys.keys[i]));
      if (textDimensions.x > maxWidth) {
        maxWidth = textDimensions.x;
      }
    }
  }
}
