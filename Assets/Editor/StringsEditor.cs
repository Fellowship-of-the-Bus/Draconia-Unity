using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;

////////////////
// Want:
//   * specify multiple languages in different files, each file must have same number of strings
//   * enum for key so that access is checked by compiler
//
// soln: two modes:
//   specify key set
//   given a keyset, show the list of strings that need to be filled out

// TODO:
// * display window as dirty when changes are pending
// * prompt save before new/load if dirty

[System.Serializable]
public class StringKeys {
  public string[] keys;
}

[System.Serializable]
public class StringValues {
  public string keysPath;
  public string[] values;
}

public class StringsEditor : EditorWindow {
  public enum Mode {
    Blank, Keys, Values
  }
  public Mode mode;
  private string activeFilePath;
  public StringKeys keys;
  public StringValues values;
  private Channel channel = new Channel("StringsEditor", true);

  [MenuItem("Window/Strings Editor")]
  static void Init() {
    EditorWindow.GetWindow(typeof(StringsEditor)).Show();
  }

  private void OnGUI() {
    switch(mode) {
      case Mode.Blank: drawBlank(); break;
      case Mode.Keys:  drawKeys(); break;
      case Mode.Values: drawValues(); break;
    }
  }

  private void drawBlank() {
    if (GUILayout.Button("New Keys")) {
      keys = new StringKeys();
      activeFilePath = null;  // new file, forget path
      mode = Mode.Keys;
    }
    if (GUILayout.Button("Load Keys")) {
      if (LoadKeys()) {
        mode = Mode.Keys;
      }
    }
    if (GUILayout.Button("New Values")) {
      if (LoadKeys()) {
        calcWidth();
        values = new StringValues();
        values.keysPath = activeFilePath;
        values.values = new string[keys.keys.Length];
        activeFilePath = null;  // new file, forget path
        mode = Mode.Values;
      }
    }
    if (GUILayout.Button("Load Values")) {
      if (LoadValues()) {
        calcWidth();
        mode = Mode.Values;
      }
    }
  }

  // needed to maintain scroll position between draw calls
  private Vector2 scrollPos;
  private void drawKeys() {
    scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
    SerializedObject serializedObject = new SerializedObject(this);
    SerializedProperty serializedProperty = serializedObject.FindProperty("keys.keys");
    EditorGUILayout.PropertyField(serializedProperty, true);
    serializedObject.ApplyModifiedProperties();

    if (GUILayout.Button("Save data")) {
      SaveKeys();
    }
    EditorGUILayout.EndScrollView();

    drawBlank();
  }

  private void drawValues() {
    Debug.Assert(keys.keys.Length == values.values.Length);

    scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
    SerializedObject serializedObject = new SerializedObject(this);
    SerializedProperty serializedProperty = serializedObject.FindProperty("values.values");
    for (int i = 0; i < keys.keys.Length; ++i) {
      EditorGUILayout.BeginHorizontal();
      GUILayout.Label(keys.keys[i], GUILayout.Width(maxWidth));
      SerializedProperty elem = serializedProperty.GetArrayElementAtIndex(i);
      EditorGUILayout.PropertyField(elem, GUIContent.none, true);
      EditorGUILayout.EndHorizontal();
    }
    serializedObject.ApplyModifiedProperties();

    if (GUILayout.Button("Save data")) { // TODO: should just ask for language/location - name should be decided by key name
      SaveValues();
    }
    EditorGUILayout.EndScrollView();

    drawBlank();
  }

  private void Save<T>(ref string filePath, T src, FilePanelData data) {
    if (string.IsNullOrEmpty(filePath)) {
      filePath = EditorUtility.SaveFilePanel(data.saveTitle, data.path, "", data.extension);
    }
    // not an else -- filePath may not have been set correctly above
    // also needs to execute even if the code above did
    if (!string.IsNullOrEmpty(filePath)) {
      FileStream file = File.Create(filePath);
      BinaryFormatter bf = new BinaryFormatter();
      bf.Serialize(file, src);
      file.Close();
    }
  }

  private void SaveKeys() {
    Save(ref activeFilePath, keys, keysData);
    if (!string.IsNullOrEmpty(activeFilePath)) {
      int begin = activeFilePath.LastIndexOf(Path.DirectorySeparatorChar) + 1;
      int end = activeFilePath.LastIndexOf('.');
      string baseName = activeFilePath.Substring(begin, end-begin);
      channel.Log("baseName is: " + baseName);

      // write enum type
      DirectoryInfo dir = System.IO.Directory.CreateDirectory(scriptPath);
      StreamWriter stream = new StreamWriter(Path.Combine(scriptPath, baseName + ".cs"));
      stream.WriteLine("// This file is automatically generated. Do no make any changes here, they will be overwritten.");
      stream.WriteLine("// All changes should be made through the StringsEditor window.");
      stream.WriteLine("namespace StringID {");
      stream.WriteLine("  public enum " + baseName + " {");
      for (int i = 0; i < keys.keys.Length; ++i) {
        stream.WriteLine("    " + keys.keys[i] + ",");
      }
      stream.WriteLine("  }");
      stream.WriteLine("}");
      stream.Flush();
      stream.Close();
    }
  }

  private void SaveValues() {
    Save(ref activeFilePath, values, valuesData);
  }

  private bool Load<T>(ref string filePath, ref T dest, FilePanelData data) {
    filePath = EditorUtility.OpenFilePanel(data.loadTitle, data.path, data.extension);
    try {
      if (!string.IsNullOrEmpty(filePath)) {
        BinaryFormatter bf = new BinaryFormatter();
        using (FileStream file = File.Open(filePath, FileMode.Open)) {
          dest = (T)bf.Deserialize(file);
          return true;
        }
      }
    } catch (SerializationException) {
      channel.Log("Corrupted " + typeof(T) + " file: " + filePath);
    }
    return false;
  }

  private bool LoadKeys() {
    return Load(ref activeFilePath, ref keys, keysData);
  }

  private bool LoadValues() {
    // TODO: cache previous values for restore on fail to load
    // TODO: needs to do a santity check that data has not gotten out of sync with keys
    if (Load(ref activeFilePath, ref values, valuesData)) {
      return Load(ref values.keysPath, ref keys, keysData);
    }
    return false;
  }

  private class FilePanelData {
    public string path;
    public string saveTitle;
    public string loadTitle;
    public string extension;
    public FilePanelData(string path, string saveTitle, string loadTitle, string extension) {
      this.path = path;
      this.saveTitle = saveTitle;
      this.loadTitle = loadTitle;
      this.extension = extension;
    }
  }
  private static FilePanelData keysData;
  private static FilePanelData valuesData;
  private static string scriptPath;

  void OnEnable() {
    scriptPath = Path.Combine(Application.dataPath, "Script/generated/strings");
    keysData = new FilePanelData(
      saveTitle: "Save keys file",
      loadTitle: "Select keys file",
      path: Path.Combine(Application.dataPath, "StringsData/keys"),
      extension: "stringkeys"
    );
    valuesData = new FilePanelData(
      saveTitle: "Save values file",
      loadTitle: "Select values file",
      path: Path.Combine(Application.dataPath, "StringsData"),
      extension: "stringvalues"
    );
  }

  private float maxWidth = 0f;
  private void calcWidth() {
    for (int i = 0; i < keys.keys.Length; ++i) {
      var textDimensions = GUI.skin.label.CalcSize(new GUIContent(keys.keys[i]));
      if (textDimensions.x > maxWidth) {
        maxWidth = textDimensions.x;
      }
    }
  }
}
